# Copyright 2019 The Avro-to-Arrow Project
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     https://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""Example of code that is generated by avro-to-arrow package."""


@numba.jit(nopython=True, nogil=True)
def message_to_buffers(row_count, block):  #, avro_schema):
    '''Parse all rows in a stream block.

    Args:
        block (             ~google.cloud.bigquery_storage_v1beta1.types.ReadRowsResponse         ):
            A block containing Avro bytes to parse into rows.
        avro_schema (fastavro.schema):
            A parsed Avro schema, used to deserialized the bytes in the
            block.

    Returns:
        Iterable[Mapping]:
            A sequence of rows, represented as dictionaries.
    '''
    position = 0
    nullbit = numba.uint8(0)

    field_0_nullmask = _make_bitarray(row_count)
    field_0_data = numpy.empty(row_count, dtype=numpy.int64)
    field_1_nullmask = _make_bitarray(row_count)
    field_1_data = numpy.empty(row_count, dtype=numpy.float64)
    field_2_nullmask = _make_bitarray(row_count)
    field_2_data = _make_bitarray(row_count)

    for i in range(row_count):
        nullbit = _rotate_nullbit(nullbit)
        nullbyte = i // 8

        position, union_type = _read_long(position, block)
        if union_type != 0:
            field_0_nullmask[nullbyte] = field_0_nullmask[nullbyte] | nullbit
            position, field_0_data[i] = _read_long(position, block)

        position, union_type = _read_long(position, block)
        if union_type != 0:
            field_1_nullmask[nullbyte] = field_1_nullmask[nullbyte] | nullbit
            position, field_1_data[i] = _read_double(position, block)

        position, union_type = _read_long(position, block)
        if union_type != 0:
            field_2_nullmask[nullbyte] = field_2_nullmask[nullbyte] | nullbit
            position, boolmask = _read_boolean(position, block)
            field_2_data[nullbyte] = field_2_data[nullbyte] | (boolmask & nullbit)

    return (
        (field_0_nullmask, field_0_data),
        (field_1_nullmask, field_1_data),
        (field_2_nullmask, field_2_data),
    )


def message_to_table(message):
    global message_to_buffers

    row_count = message.avro_rows.row_count
    block = message.avro_rows.serialized_binary_rows
    field_0, field_1, field_2 = message_to_buffers(row_count, block)
    field_0_nullmask, field_0_rows = field_0
    field_0_array = pyarrow.Array.from_buffers(pyarrow.int64(), row_count, [
        pyarrow.py_buffer(field_0_nullmask),
        pyarrow.py_buffer(field_0_rows),
    ])
    field_1_nullmask, field_1_rows = field_1
    field_1_array = pyarrow.Array.from_buffers(pyarrow.float64(), row_count, [
        pyarrow.py_buffer(field_1_nullmask),
        pyarrow.py_buffer(field_1_rows),
    ])
    field_2_nullmask, field_2_rows = field_2
    field_2_array = pyarrow.Array.from_buffers(pyarrow.bool_(), row_count, [
        pyarrow.py_buffer(field_2_nullmask),
        pyarrow.py_buffer(field_2_rows),
    ])
    return pyarrow.Table.from_arrays([field_0_array, field_1_array, field_2_array], names=['int_col', 'float_col', 'bool_col'])
